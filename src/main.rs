// https://old.reddit.com/r/dailyprogrammer/comments/jfcuz5/20201021_challenge_386_intermediate_partition/
// Partition Counts

use std::time::Instant;

use daily_programmer_386::*;

fn main() {
    let target_n = 666_666;
    println!("Calculating {}\n", target_n);
    let true_answer: crate::bigint::BigInt = ANSWER_666666.parse().unwrap();

    let width = 12;

    let prefix = "serial";
    let start = Instant::now();
    let answer = calc_partition_count(target_n);
    let elapsed = start.elapsed();
    println!("{:width$} {:?}", prefix, elapsed, width = width);
    assert_eq!(true_answer, answer, "The numbers didn't match D:");

    println!();

    let num_threads = 12;

    let prefix = format!("parallel {:02}", num_threads);
    let start = Instant::now();
    let answer_parallel = calc_partition_count_parallel(target_n, num_threads);
    let elapsed = start.elapsed();
    println!("{:width$} {:?}", prefix, elapsed, width = width);
    assert_eq!(true_answer, answer_parallel, "The numbers didn't match D:");
    // println!("{:width$} {:?}", prefix, answer_parallel, width = width);
    // println!();
}

const ANSWER_666666: &str = "82988204725057268470089990261324378276360276281620\
1701722599315815312910790359761069230836156205082863018110775536469855308986200\
0731442486629159021107871890767548744981563757815604738193831935702672342940081\
1440786243537473889613789501179860271205636766685556083839284871356467505472932\
9398073507378373208972509842880751022273604950120819819461244250221006793015786\
7203009814706076130473690071075547021163614324905624193405855948355599300631813\
0882354490793855633514786018860641508968599291753911710658821984824827014879253\
2079530603636993578091236835691954161244027792120896238596848636567612717269000\
7842504280069247466174500335672400845138118174848452879574540446797810703795044\
3578207396880201632718267240214781649888665835052129794930921847857093479519752\
3632953503835428280916586305632528116828229355871664575877094278615695592039186\
556142662054263695788587794970386821424021653983372333685780633";

// #[cfg(test)]
// mod tests {
//     // const ANSWER_666666: &str = "829882047250572684700899902613243782763602762816201701722599315815312910790359761069230836156205082863018110775536469855308986200073144248662915902110787189076754874498156375781560473819383193570267234294008114407862435374738896137895011798602712056367666855560838392848713564675054729329398073507378373208972509842880751022273604950120819819461244250221006793015786720300981470607613047369007107554702116361432490562419340585594835559930063181308823544907938556335147860188606415089685992917539117106588219848248270148792532079530603636993578091236835691954161244027792120896238596848636567612717269000784250428006924746617450033567240084513811817484845287957454044679781070379504435782073968802016327182672402147816498886658350521297949309218478570934795197523632953503835428280916586305632528116828229355871664575877094278615695592039186556142662054263695788587794970386821424021653983372333685780633";
//     const ANSWER_666: &str = "11956824258286445517629485";
//     use crate::bigint::BigInt;
//     use crate::calc_partition_count_parallel;

//     #[test]
//     #[cfg(loom)]
//     fn loom_parallel_correct() {
//         loom::model(|| {
//             let true_answer: BigInt = ANSWER_666.parse().unwrap();
//             let parallel_answer = calc_partition_count_parallel(666, 12);
//             assert_eq!(parallel_answer, true_answer);
//         });
//     }
// }
